---
layout: post
title: "数据库悲观锁与乐观锁"
description: "数据库悲观锁与乐观锁"
categories: [Mysql]
tags: [Mysql]
redirect_from:
  - /2016/11/26/
---

> 数据库悲观锁与乐观锁
> 数据库管理系统(DBMS)中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不被破坏事务的隔离性和统一性以及数据库的统一性。
> 乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。
> 无论是悲观锁还是乐观锁都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，想memcache，hibernate，tair等都有类似的概念。
> 针对不同的业务场景，应该选不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据库中提供的锁机制(行锁，表锁，排他锁，共享锁)混为一谈。
> 其实在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。

* Kramdown table of contents
{:toc .toc}

# 悲观锁

> 在关系数据库管理系统里，悲观并发控制(又名“悲观锁”，Pessimistic Concurrency Control,缩写“PCC”)是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来
> 修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。
> 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

悲观锁，正如其名，它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。
悲观锁的实现，往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)

## 数据库中，悲观锁流程

   对任务记录进行修改前，先尝试为该记录加上排他锁(exclusive locking)。  
   如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。 
   如果加锁成功，那么就可以对记录做修改，事务完成后就会解锁。
   期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。
   
## Mysql中 Innodb使用排他锁

   要使用悲观锁，必须关闭Mysql的事务自动提交变量，因为Mysql的默认autocommit值为1，也就是自动提交模式，当执行一个更新操作后，Mysql会立刻将结果自动提交，因此需要set autocommit=0;
   	
~~~ ruby
//查询当前autocommit值
mysql> select @@autocommit;
+--------------+
| @@autocommit |
+--------------+
|            1 |
+--------------+

//设置并查看autocommit值
mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> select @@autocommit;
+--------------+
| @@autocommit |
+--------------+
|            0 |
+--------------+
~~~

实验过程

~~~ ruby
//0.开始事务
begin;/begin work;/start transaction; (三者选一就可以)
//1.查询出商品信息
select status from t_goods where id=1 for update;
//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);
//3.修改商品status为2
update t_goods set status=2;
//4.提交事务
commit;/commit work;
~~~

	上面的查询语句过程中，我们使用了*select…for update*{: style="color: red"}会把数据给锁住，锁的级别与引擎相关，Mysql Innodb默认为行级锁。行级锁都是基于索引的，如果一条SQL语句
	用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。
	
> 注意：

> SELECT，INSERT，UPDATE或DELETE都会开启事务。
> 如果AUTOCOMMIT设置为1（默认值），每一个SQL语句都被认为是一个完整的事务。 AUTOCOMMIT设置为0时，在随后的一系列语句的作用就像一个事务，直到一个明确的COMMIT语句结束。
	
## 优点与不足

   悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保障。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会，
   另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还会降低系统并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完
   才可以处理那行。
 
# 乐观锁

> 在关系数据库管理系统中，乐观并发控制(又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”)是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，
> 各事务能够在不产生锁的情况下处理各自影响的那部分数据，在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他的数据又修改了该数据。如果有其他数据更新的话，
> 正在提交的事务会进行回滚。

乐观锁(Optimistic Locking)相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回用户的错误信息
让用户决定如何去做。
相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般实现乐观锁的方式就是记录数据版本。

> 数据版本，为数据增加的一个版本标示。当读取数据时，将版本标示的值一同读出，数据每更新一次，同时对版本标示进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次
> 取出来的版本表示进行比对，如果数据库当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

*实现数据版本有两种方式：1、使用版本号，2、使用时间戳；*{: style="color: red"}
	
## 优点与不足

   乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。
   但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。
